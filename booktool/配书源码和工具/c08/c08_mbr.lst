     1                                           ;代码清单8-1
     2                                           ;文件名：c08_mbr.asm
     3                                           ;文件说明：硬盘主引导扇区代码（加载程序） 
     4                                           ;创建日期：2011-5-5 18:17
     5                                           
     6                                           app_lba_start equ 100           ;声明常数（用户程序起始逻辑扇区号）
     7                                                                           ;常数的声明不会占用汇编地址
     8                                                                      
     9                                  SECTION mbr align=16 vstart=0x7c00                                     
    10                                  
    11                                           ;设置堆栈段和栈指针 
    12 00000000 B80000                           mov ax,0      
    13 00000003 8ED0                             mov ss,ax
    14 00000005 89C4                             mov sp,ax
    15                                  		 ; -- 逻辑段地址 * 16 + 逻辑偏移地址 = 物理地址 ，所以除以16
    16 00000007 2EA1[C700]                       mov ax,[cs:phy_base]            ;计算用于加载用户程序的逻辑段地址 
    17 0000000B 2E8B16[C900]                     mov dx,[cs:phy_base+0x02]
    18 00000010 BB1000                           mov bx,16                       ; -- 除以16，即10H
    19 00000013 F7F3                             div bx                          ; -- ax中得到逻辑段地址
    20 00000015 8ED8                             mov ds,ax                       ;令DS和ES指向该段以进行操作
    21 00000017 8EC0                             mov es,ax                        
    22                                      
    23                                           ;以下读取程序的起始部分 
    24 00000019 31FF                             xor di,di
    25 0000001B BE6400                           mov si,app_lba_start            ;程序在硬盘上的起始逻辑扇区号 
    26 0000001E 31DB                             xor bx,bx                       ;加载到DS:0x0000处 
    27 00000020 E85100                           call read_hard_disk_0
    28                                        
    29                                           ;以下判断整个程序有多大  -- dx:ax 就是用户程序大小
    30 00000023 8B160200                         mov dx,[2]                      ;曾经把dx写成了ds，花了二十分钟排错 
    31 00000027 A10000                           mov ax,[0]
    32 0000002A BB0002                           mov bx,512                      ;512字节每扇区
    33 0000002D F7F3                             div bx                          ; -- 除以512字节 ，就能得到用户程序占用多少个扇区了
    34 0000002F 83FA00                           cmp dx,0                        ; 在凑巧的情况下，用户程序的大小 正好是512的整数倍，做完除法后在寄存器AX中是用户程序实际占用的扇区数,如果dx不为0（有余数）
    35 00000032 7501                             jnz @1                          ;未除尽，因此结果比实际扇区数少1 
    36 00000034 48                               dec ax                          ;已经读了一个扇区，扇区总数减1 -- 在前面第27行代码已经调用过一次read_hard_disk_0了
    37                                     @1:
    38 00000035 83F800                           cmp ax,0                        ;考虑实际长度小于等于512个字节的情况 -- 可能小于1个扇区的情况那么ax会等于0
    39 00000038 7413                             jz direct                       ; -- ax=0的情况，跳转到direct，意味着只有1个扇区，前面读过了
    40                                           
    41                                           ;读取剩余的扇区
    42 0000003A 1E                               push ds                         ;以下要用到并改变DS寄存器 
    43                                  
    44 0000003B 89C1                             mov cx,ax                       ;循环次数（剩余扇区数）
    45                                     @2:
    46 0000003D 8CD8                             mov ax,ds
    47 0000003F 83C020                           add ax,0x20                     ;得到下一个以512字节为边界的段地址
    48 00000042 8ED8                             mov ds,ax  
    49                                                                
    50 00000044 31DB                             xor bx,bx                       ;每次读时，偏移地址始终为0x0000 
    51 00000046 46                               inc si                          ;下一个逻辑扇区 
    52 00000047 E82A00                           call read_hard_disk_0
    53 0000004A E2F1                             loop @2                         ;循环读，直到读完整个功能程序 
    54                                  
    55 0000004C 1F                               pop ds                          ;恢复数据段基址到用户程序头部段 
    56                                        
    57                                           ;计算入口点代码段基址 
    58                                     direct:
    59 0000004D 8B160800                         mov dx,[0x08]                    ; --用户程序段地址高位
    60 00000051 A10600                           mov ax,[0x06]                    ; --用户程序段地址低位
    61 00000054 E85700                           call calc_segment_base
    62 00000057 A30600                           mov [0x06],ax                   ;回填修正后的入口点代码段基址 
    63                                        
    64                                           ;开始处理段重定位表
    65 0000005A 8B0E0A00                         mov cx,[0x0a]                   ;需要重定位的项目数量
    66 0000005E BB0C00                           mov bx,0x0c                     ;重定位表首地址
    67                                            
    68                                   realloc:
    69 00000061 8B5702                           mov dx,[bx+0x02]                ;32位地址的高16位 
    70 00000064 8B07                             mov ax,[bx]
    71 00000066 E84500                           call calc_segment_base
    72 00000069 8907                             mov [bx],ax                     ;回填段的基址
    73 0000006B 83C304                           add bx,4                        ;下一个重定位项（每项占4个字节） 
    74 0000006E E2F1                             loop realloc 
    75                                        
    76 00000070 FF2E0400                         jmp far [0x04]                  ;转移到用户程序  
    77                                   
    78                                  ;-------------------------------------------------------------------------------
    79                                  read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区
    80                                                                           ;输入：DI:SI=起始逻辑扇区号
    81                                                                           ;      DS:BX=目标缓冲区地址
    82 00000074 50                               push ax
    83 00000075 53                               push bx
    84 00000076 51                               push cx
    85 00000077 52                               push dx
    86                                        
    87 00000078 BAF201                           mov dx,0x1f2
    88 0000007B B001                             mov al,1
    89 0000007D EE                               out dx,al                       ;读取的扇区数
    90                                  
    91 0000007E 42                               inc dx                          ;0x1f3
    92 0000007F 89F0                             mov ax,si
    93 00000081 EE                               out dx,al                       ;LBA地址7~0
    94                                  
    95 00000082 42                               inc dx                          ;0x1f4
    96 00000083 88E0                             mov al,ah
    97 00000085 EE                               out dx,al                       ;LBA地址15~8
    98                                  
    99 00000086 42                               inc dx                          ;0x1f5
   100 00000087 89F8                             mov ax,di
   101 00000089 EE                               out dx,al                       ;LBA地址23~16
   102                                  
   103 0000008A 42                               inc dx                          ;0x1f6
   104 0000008B B0E0                             mov al,0xe0                     ;LBA28模式，主盘
   105 0000008D 08E0                             or al,ah                        ;LBA地址27~24 --  al = 11100000  高3位是111 ，第6位是1，表示LBA模式，第4位是0表示主硬盘，见书上图8-11 端口1f6各位的含义
   106 0000008F EE                               out dx,al
   107                                  
   108 00000090 42                               inc dx                          ;0x1f7
   109 00000091 B020                             mov al,0x20                     ;读命令
   110 00000093 EE                               out dx,al
   111                                  
   112                                    .waits:                               ; -- 这个子过程主要判断磁盘是否忙完
   113 00000094 EC                               in al,dx
   114 00000095 2488                             and al,0x88                    ; -- 0x88的二进制是10001000 ，and 表示 第7位和第3位才会可能是1，其他全是0
   115 00000097 3C08                             cmp al,0x08					; -- 0x08的二进制是1000 ，比较如果是1000就不忙，已准备好
   116 00000099 75F9                             jnz .waits                      ;不忙，且硬盘已准备好数据传输 
   117                                  
   118 0000009B B90001                           mov cx,256                      ;总共要读取的字数 -- 猜测因为下面是ax，每次是读2个字节，所以循环256次就可以了
   119 0000009E BAF001                           mov dx,0x1f0
   120                                    .readw:
   121 000000A1 ED                               in ax,dx
   122 000000A2 8907                             mov [bx],ax
   123 000000A4 83C302                           add bx,2
   124 000000A7 E2F8                             loop .readw
   125                                  
   126 000000A9 5A                               pop dx
   127 000000AA 59                               pop cx
   128 000000AB 5B                               pop bx
   129 000000AC 58                               pop ax
   130                                        
   131 000000AD C3                               ret
   132                                  
   133                                  ;-------------------------------------------------------------------------------
   134                                  calc_segment_base:                       ;计算16位段地址
   135                                                                           ;输入：DX:AX=32位物理地址
   136                                                                           ;返回：AX=16位段基地址 
   137 000000AE 52                               push dx                          
   138                                           
   139 000000AF 2E0306[C700]                     add ax,[cs:phy_base]            ;-- 低16位
   140 000000B4 2E1316[C900]                     adc dx,[cs:phy_base+0x02]       ; --高16位,adc带进位加法
   141 000000B9 C1E804                           shr ax,4                        ; --右移4位，相当于除以16(10H)，空出ax的高4位，是为了后面得到逻辑段地址
   142 000000BC C1CA04                           ror dx,4                        ; -- ror(Rotate Right)指令循环右移，右边的4位(从最右边开始)依次移动到左边
   143 000000BF 81E200F0                         and dx,0xf000                   ; -- 0xf000二进制1111000000000000，只保有效留高4位，其余位清除置为0，因为理论上只有20位是有效
   144 000000C3 09D0                             or ax,dx                        ; -- or指令合并 ax和dx中的值
   145                                           
   146 000000C5 5A                               pop dx
   147                                           
   148 000000C6 C3                               ret
   149                                  
   150                                  ;-------------------------------------------------------------------------------
   151 000000C7 00000100                         phy_base dd 0x10000             ;用户程序被加载的物理起始地址
   152                                           
   153 000000CB 00<rep 133h>             times 510-($-$$) db 0
   154 000001FE 55AA                                      db 0x55,0xaa
